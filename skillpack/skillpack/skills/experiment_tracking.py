"""experiment-tracking - Generate MLflow or W&B tracking boilerplate."""

import argparse
from datetime import datetime
from pathlib import Path
from textwrap import dedent
from typing import Any

from skillpack.utils.output import get_output_dir, write_text


def handler(args: argparse.Namespace) -> int:
    """CLI handler for experiment-tracking."""
    result = experiment_tracking_main(
        project_name=args.name,
        tracker=args.tracker,
        output_dir=args.output_dir,
    )

    if result.get("success"):
        print(f"✅ Generated tracking setup: {result['output_dir']}")
        for f in result.get("files", []):
            print(f"   - {f}")
        return 0
    print(f"❌ Error: {result.get('error')}")
    return 1


def register_parser(subparsers: Any) -> None:
    """Register the experiment-tracking subcommand."""
    parser = subparsers.add_parser(
        "experiment-tracking",
        help="Generate MLflow or W&B tracking boilerplate",
    )
    parser.add_argument("--name", required=True, help="Project name")
    parser.add_argument(
        "--tracker",
        choices=["mlflow", "wandb", "both"],
        default="mlflow",
        help="Tracking framework",
    )
    parser.add_argument(
        "--output-dir",
        type=Path,
        default=Path("./out/experiment_tracking"),
        help="Output directory",
    )
    parser.set_defaults(handler=handler)


def experiment_tracking_main(
    project_name: str,
    tracker: str = "mlflow",
    output_dir: Path | None = None,
) -> dict[str, Any]:
    """Generate experiment tracking boilerplate."""
    if output_dir is None:
        output_dir = get_output_dir("experiment_tracking")
    else:
        output_dir.mkdir(parents=True, exist_ok=True)

    try:
        files = []

        if tracker in ["mlflow", "both"]:
            mlflow_code = generate_mlflow_tracker(project_name)
            write_text(content=mlflow_code, filename="mlflow_tracker.py", skill_name="experiment_tracking", output_dir=output_dir)
            files.append("mlflow_tracker.py")

        if tracker in ["wandb", "both"]:
            wandb_code = generate_wandb_tracker(project_name)
            write_text(content=wandb_code, filename="wandb_tracker.py", skill_name="experiment_tracking", output_dir=output_dir)
            files.append("wandb_tracker.py")

        # Generate unified interface
        interface = generate_tracking_interface(project_name)
        write_text(content=interface, filename="tracker.py", skill_name="experiment_tracking", output_dir=output_dir)
        files.append("tracker.py")

        # Generate config
        config = generate_tracking_config(project_name, tracker)
        write_text(content=config, filename="tracking_config.yaml", skill_name="experiment_tracking", output_dir=output_dir)
        files.append("tracking_config.yaml")

        return {
            "success": True,
            "output_dir": str(output_dir),
            "files": files,
        }

    except Exception as e:
        return {"success": False, "error": str(e)}


def generate_mlflow_tracker(name: str) -> str:
    """Generate MLflow tracking wrapper."""
    return dedent(f'''\
        """MLflow experiment tracking for {name}.

        Generated by skillpack on {datetime.now().strftime("%Y-%m-%d %H:%M")}
        """

        import os
        from contextlib import contextmanager
        from pathlib import Path
        from typing import Any

        import mlflow
        from mlflow.tracking import MlflowClient


        class MLflowTracker:
            """MLflow experiment tracker."""
            
            def __init__(
                self,
                experiment_name: str = "{name}",
                tracking_uri: str | None = None,
            ):
                self.experiment_name = experiment_name
                self.tracking_uri = tracking_uri or os.getenv(
                    "MLFLOW_TRACKING_URI", "mlruns"
                )
                
                mlflow.set_tracking_uri(self.tracking_uri)
                mlflow.set_experiment(experiment_name)
                
                self.client = MlflowClient()
                self.run = None
            
            @contextmanager
            def start_run(self, run_name: str | None = None, tags: dict | None = None):
                """Context manager for MLflow run."""
                with mlflow.start_run(run_name=run_name, tags=tags) as run:
                    self.run = run
                    yield self
                    self.run = None
            
            def log_params(self, params: dict[str, Any]) -> None:
                """Log parameters."""
                mlflow.log_params(params)
            
            def log_metrics(self, metrics: dict[str, float], step: int | None = None) -> None:
                """Log metrics."""
                mlflow.log_metrics(metrics, step=step)
            
            def log_metric(self, key: str, value: float, step: int | None = None) -> None:
                """Log single metric."""
                mlflow.log_metric(key, value, step=step)
            
            def log_artifact(self, path: str | Path, artifact_path: str | None = None) -> None:
                """Log artifact file."""
                mlflow.log_artifact(str(path), artifact_path)
            
            def log_model(self, model: Any, artifact_path: str = "model") -> None:
                """Log sklearn model."""
                mlflow.sklearn.log_model(model, artifact_path)
            
            def set_tags(self, tags: dict[str, str]) -> None:
                """Set run tags."""
                mlflow.set_tags(tags)
            
            def get_best_run(self, metric: str, ascending: bool = False) -> dict:
                """Get best run by metric."""
                experiment = mlflow.get_experiment_by_name(self.experiment_name)
                runs = self.client.search_runs(
                    experiment_ids=[experiment.experiment_id],
                    order_by=[f"metrics.{{metric}} {{'ASC' if ascending else 'DESC'}}"],
                    max_results=1,
                )
                return runs[0] if runs else None


        # Example usage
        if __name__ == "__main__":
            tracker = MLflowTracker()
            
            with tracker.start_run(run_name="test_run"):
                tracker.log_params({{"lr": 0.01, "epochs": 10}})
                
                for epoch in range(10):
                    tracker.log_metrics({{"loss": 0.5 - epoch * 0.05}}, step=epoch)
                
                print("Run logged successfully!")
    ''')


def generate_wandb_tracker(name: str) -> str:
    """Generate W&B tracking wrapper."""
    return dedent(f'''\
        """W&B experiment tracking for {name}.

        Generated by skillpack on {datetime.now().strftime("%Y-%m-%d %H:%M")}
        """

        import os
        from contextlib import contextmanager
        from pathlib import Path
        from typing import Any

        import wandb


        class WandbTracker:
            """Weights & Biases experiment tracker."""
            
            def __init__(
                self,
                project: str = "{name}",
                entity: str | None = None,
            ):
                self.project = project
                self.entity = entity or os.getenv("WANDB_ENTITY")
                self.run = None
            
            @contextmanager
            def start_run(
                self,
                run_name: str | None = None,
                config: dict | None = None,
                tags: list[str] | None = None,
            ):
                """Context manager for W&B run."""
                self.run = wandb.init(
                    project=self.project,
                    entity=self.entity,
                    name=run_name,
                    config=config,
                    tags=tags,
                )
                try:
                    yield self
                finally:
                    wandb.finish()
                    self.run = None
            
            def log_params(self, params: dict[str, Any]) -> None:
                """Log parameters (via config update)."""
                wandb.config.update(params)
            
            def log_metrics(self, metrics: dict[str, float], step: int | None = None) -> None:
                """Log metrics."""
                if step is not None:
                    metrics["step"] = step
                wandb.log(metrics)
            
            def log_metric(self, key: str, value: float, step: int | None = None) -> None:
                """Log single metric."""
                self.log_metrics({{key: value}}, step=step)
            
            def log_artifact(
                self,
                path: str | Path,
                name: str | None = None,
                artifact_type: str = "dataset",
            ) -> None:
                """Log artifact."""
                artifact = wandb.Artifact(name or Path(path).stem, type=artifact_type)
                artifact.add_file(str(path))
                wandb.log_artifact(artifact)
            
            def log_model(self, model: Any, name: str = "model") -> None:
                """Log model as artifact."""
                import tempfile
                import joblib
                
                with tempfile.NamedTemporaryFile(suffix=".pkl", delete=False) as f:
                    joblib.dump(model, f.name)
                    self.log_artifact(f.name, name, artifact_type="model")
            
            def log_table(self, key: str, columns: list, data: list) -> None:
                """Log table data."""
                table = wandb.Table(columns=columns, data=data)
                wandb.log({{key: table}})
            
            def log_image(self, key: str, image: Any, caption: str | None = None) -> None:
                """Log image."""
                wandb.log({{key: wandb.Image(image, caption=caption)}})


        # Example usage
        if __name__ == "__main__":
            tracker = WandbTracker()
            
            with tracker.start_run(run_name="test_run", config={{"lr": 0.01}}):
                for epoch in range(10):
                    tracker.log_metrics({{"loss": 0.5 - epoch * 0.05}}, step=epoch)
                
                print("Run logged successfully!")
    ''')


def generate_tracking_interface(name: str) -> str:
    """Generate unified tracking interface."""
    return dedent(f'''\
        """Unified experiment tracking interface for {name}.

        Generated by skillpack on {datetime.now().strftime("%Y-%m-%d %H:%M")}
        """

        from abc import ABC, abstractmethod
        from contextlib import contextmanager
        from pathlib import Path
        from typing import Any, Protocol


        class ExperimentTracker(Protocol):
            """Protocol for experiment trackers."""
            
            def log_params(self, params: dict[str, Any]) -> None: ...
            def log_metrics(self, metrics: dict[str, float], step: int | None = None) -> None: ...
            def log_artifact(self, path: str | Path, artifact_path: str | None = None) -> None: ...


        def get_tracker(tracker_type: str = "mlflow", **kwargs) -> ExperimentTracker:
            """Factory function to get tracker instance."""
            if tracker_type == "mlflow":
                from mlflow_tracker import MLflowTracker
                return MLflowTracker(**kwargs)
            elif tracker_type == "wandb":
                from wandb_tracker import WandbTracker
                return WandbTracker(**kwargs)
            else:
                raise ValueError(f"Unknown tracker type: {{tracker_type}}")


        class NoOpTracker:
            """No-op tracker for testing or when tracking is disabled."""
            
            @contextmanager
            def start_run(self, **kwargs):
                yield self
            
            def log_params(self, params: dict) -> None:
                pass
            
            def log_metrics(self, metrics: dict, step: int | None = None) -> None:
                pass
            
            def log_artifact(self, path: str | Path, artifact_path: str | None = None) -> None:
                pass
    ''')


def generate_tracking_config(name: str, tracker: str) -> str:
    """Generate tracking configuration."""
    import yaml
    
    return yaml.dump({
        "project": name,
        "tracker": tracker,
        "mlflow": {
            "tracking_uri": "mlruns",
            "artifact_location": "./artifacts",
        },
        "wandb": {
            "entity": None,
            "mode": "online",
        },
        "logging": {
            "log_system_metrics": True,
            "log_code": True,
        },
    }, default_flow_style=False)
