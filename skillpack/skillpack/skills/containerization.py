"""containerization - Generate Dockerfile and compose configs for services."""

import argparse
from datetime import datetime
from pathlib import Path
from textwrap import dedent
from typing import Any

from skillpack.utils.output import get_output_dir, write_text


def handler(args: argparse.Namespace) -> int:
    """CLI handler for containerization."""
    result = containerization_main(
        service_name=args.name,
        base_image=args.base,
        runtime=args.runtime,
        port=args.port,
        with_compose=args.compose,
        output_dir=args.output_dir,
    )

    if result.get("success"):
        print(f"✅ Generated container configs in {result['output_dir']}")
        for f in result.get("files", []):
            print(f"   - {f}")
        return 0
    print(f"❌ Error: {result.get('error')}")
    return 1


def register_parser(subparsers: Any) -> None:
    """Register the containerization subcommand."""
    parser = subparsers.add_parser(
        "containerization",
        help="Generate Dockerfile and compose configs for services",
    )
    parser.add_argument("--name", required=True, help="Service name")
    parser.add_argument(
        "--base",
        choices=["python", "node", "go", "rust"],
        default="python",
        help="Base image type",
    )
    parser.add_argument(
        "--runtime",
        choices=["uvicorn", "gunicorn", "node", "binary"],
        default="uvicorn",
        help="Runtime type",
    )
    parser.add_argument("--port", type=int, default=8000, help="Exposed port")
    parser.add_argument("--compose", action="store_true", help="Generate docker-compose.yml")
    parser.add_argument(
        "--output-dir",
        type=Path,
        default=Path("./out/containerization"),
        help="Output directory",
    )
    parser.set_defaults(handler=handler)


def containerization_main(
    service_name: str,
    base_image: str = "python",
    runtime: str = "uvicorn",
    port: int = 8000,
    with_compose: bool = True,
    output_dir: Path | None = None,
) -> dict[str, Any]:
    """Generate container configuration files."""
    if output_dir is None:
        output_dir = get_output_dir("containerization")
    else:
        output_dir.mkdir(parents=True, exist_ok=True)

    try:
        files = []

        # Generate Dockerfile
        dockerfile = generate_dockerfile(service_name, base_image, runtime, port)
        write_text(content=dockerfile, filename="Dockerfile", skill_name="containerization", output_dir=output_dir)
        files.append("Dockerfile")

        # Generate .dockerignore
        dockerignore = generate_dockerignore(base_image)
        write_text(content=dockerignore, filename=".dockerignore", skill_name="containerization", output_dir=output_dir)
        files.append(".dockerignore")

        # Generate docker-compose.yml
        if with_compose:
            compose = generate_compose(service_name, port)
            write_text(content=compose, filename="docker-compose.yml", skill_name="containerization", output_dir=output_dir)
            files.append("docker-compose.yml")

        # Generate Makefile for common commands
        makefile = generate_makefile(service_name)
        write_text(content=makefile, filename="Makefile", skill_name="containerization", output_dir=output_dir)
        files.append("Makefile")

        # Generate README
        readme = generate_readme(service_name, port, with_compose)
        write_text(content=readme, filename="DOCKER_README.md", skill_name="containerization", output_dir=output_dir)
        files.append("DOCKER_README.md")

        return {
            "success": True,
            "output_dir": str(output_dir),
            "files": files,
        }

    except Exception as e:
        return {"success": False, "error": str(e)}


def generate_dockerfile(
    service_name: str, base_image: str, runtime: str, port: int
) -> str:
    """Generate Dockerfile based on runtime."""
    
    if base_image == "python":
        return dedent(f'''\
            # Dockerfile for {service_name}
            # Generated by skillpack containerization on {datetime.now().strftime("%Y-%m-%d %H:%M")}

            # Build stage
            FROM python:3.11-slim as builder

            WORKDIR /app

            # Install build dependencies
            RUN apt-get update && apt-get install -y --no-install-recommends \\
                build-essential \\
                && rm -rf /var/lib/apt/lists/*

            # Install Python dependencies
            COPY requirements.txt .
            RUN pip wheel --no-cache-dir --no-deps --wheel-dir /app/wheels -r requirements.txt

            # Production stage
            FROM python:3.11-slim

            WORKDIR /app

            # Create non-root user
            RUN groupadd -r appuser && useradd -r -g appuser appuser

            # Copy wheels from builder
            COPY --from=builder /app/wheels /wheels
            RUN pip install --no-cache /wheels/*

            # Copy application
            COPY . .

            # Set ownership
            RUN chown -R appuser:appuser /app
            USER appuser

            # Environment
            ENV PYTHONUNBUFFERED=1
            ENV PYTHONDONTWRITEBYTECODE=1

            # Health check
            HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\
                CMD python -c "import urllib.request; urllib.request.urlopen('http://localhost:{port}/health')" || exit 1

            EXPOSE {port}

            # Run
            {"CMD [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"" + str(port) + "\"]" if runtime == "uvicorn" else "CMD [\"gunicorn\", \"-w\", \"4\", \"-k\", \"uvicorn.workers.UvicornWorker\", \"-b\", \"0.0.0.0:" + str(port) + "\", \"main:app\"]"}
        ''')
    
    elif base_image == "node":
        return dedent(f'''\
            # Dockerfile for {service_name}
            # Generated by skillpack containerization on {datetime.now().strftime("%Y-%m-%d %H:%M")}

            FROM node:20-slim as builder

            WORKDIR /app

            COPY package*.json ./
            RUN npm ci --only=production

            FROM node:20-slim

            WORKDIR /app

            RUN groupadd -r appuser && useradd -r -g appuser appuser

            COPY --from=builder /app/node_modules ./node_modules
            COPY . .

            RUN chown -R appuser:appuser /app
            USER appuser

            ENV NODE_ENV=production

            HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\
                CMD curl -f http://localhost:{port}/health || exit 1

            EXPOSE {port}

            CMD ["node", "index.js"]
        ''')
    
    elif base_image == "go":
        return dedent(f'''\
            # Dockerfile for {service_name}
            # Generated by skillpack containerization on {datetime.now().strftime("%Y-%m-%d %H:%M")}

            FROM golang:1.21-alpine as builder

            WORKDIR /app

            COPY go.mod go.sum ./
            RUN go mod download

            COPY . .
            RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .

            FROM alpine:latest

            RUN apk --no-cache add ca-certificates
            RUN addgroup -S appuser && adduser -S appuser -G appuser

            WORKDIR /app

            COPY --from=builder /app/main .

            RUN chown -R appuser:appuser /app
            USER appuser

            HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\
                CMD wget --no-verbose --tries=1 --spider http://localhost:{port}/health || exit 1

            EXPOSE {port}

            CMD ["./main"]
        ''')
    
    else:  # rust
        return dedent(f'''\
            # Dockerfile for {service_name}
            # Generated by skillpack containerization on {datetime.now().strftime("%Y-%m-%d %H:%M")}

            FROM rust:1.73-slim as builder

            WORKDIR /app

            COPY Cargo.toml Cargo.lock ./
            RUN mkdir src && echo "fn main() {{}}" > src/main.rs
            RUN cargo build --release && rm -rf src

            COPY . .
            RUN touch src/main.rs && cargo build --release

            FROM debian:bookworm-slim

            RUN apt-get update && apt-get install -y --no-install-recommends ca-certificates \\
                && rm -rf /var/lib/apt/lists/*

            RUN groupadd -r appuser && useradd -r -g appuser appuser

            WORKDIR /app

            COPY --from=builder /app/target/release/{service_name} .

            RUN chown -R appuser:appuser /app
            USER appuser

            EXPOSE {port}

            CMD ["./{service_name}"]
        ''')


def generate_dockerignore(base_image: str) -> str:
    """Generate .dockerignore file."""
    common = """\
# Git
.git
.gitignore

# IDE
.idea/
.vscode/
*.swp
*.swo

# Docker
Dockerfile*
docker-compose*
.docker/

# CI/CD
.github/
.gitlab-ci.yml

# Documentation
*.md
docs/

# Tests
tests/
*_test.*
"""
    
    if base_image == "python":
        return common + """\
# Python
__pycache__/
*.py[cod]
*$py.class
.Python
.env
.venv
venv/
*.egg-info/
.pytest_cache/
.mypy_cache/
.coverage
htmlcov/
"""
    elif base_image == "node":
        return common + """\
# Node
node_modules/
npm-debug.log*
.npm
*.log
"""
    elif base_image == "go":
        return common + """\
# Go
*.exe
*.exe~
*.dll
*.so
*.dylib
vendor/
"""
    else:  # rust
        return common + """\
# Rust
target/
**/*.rs.bk
Cargo.lock
"""


def generate_compose(service_name: str, port: int) -> str:
    """Generate docker-compose.yml."""
    return dedent(f'''\
        # docker-compose.yml for {service_name}
        # Generated by skillpack containerization on {datetime.now().strftime("%Y-%m-%d %H:%M")}

        version: "3.9"

        services:
          {service_name}:
            build:
              context: .
              dockerfile: Dockerfile
            container_name: {service_name}
            ports:
              - "{port}:{port}"
            environment:
              - LOG_LEVEL=info
            volumes:
              - ./data:/app/data:ro
            healthcheck:
              test: ["CMD", "curl", "-f", "http://localhost:{port}/health"]
              interval: 30s
              timeout: 10s
              retries: 3
              start_period: 10s
            restart: unless-stopped
            networks:
              - {service_name}-network

          # Uncomment for Redis cache
          # redis:
          #   image: redis:7-alpine
          #   container_name: {service_name}-redis
          #   ports:
          #     - "6379:6379"
          #   networks:
          #     - {service_name}-network

        networks:
          {service_name}-network:
            driver: bridge

        volumes:
          {service_name}-data:
    ''')


def generate_makefile(service_name: str) -> str:
    """Generate Makefile for Docker commands."""
    return dedent(f'''\
        # Makefile for {service_name} Docker commands
        # Generated by skillpack containerization

        .PHONY: build run stop logs shell clean push

        IMAGE_NAME = {service_name}
        CONTAINER_NAME = {service_name}
        TAG = latest

        build:
        \t@docker build -t $(IMAGE_NAME):$(TAG) .

        run: build
        \t@docker run -d --name $(CONTAINER_NAME) -p 8000:8000 $(IMAGE_NAME):$(TAG)

        stop:
        \t@docker stop $(CONTAINER_NAME) || true
        \t@docker rm $(CONTAINER_NAME) || true

        logs:
        \t@docker logs -f $(CONTAINER_NAME)

        shell:
        \t@docker exec -it $(CONTAINER_NAME) /bin/sh

        clean: stop
        \t@docker rmi $(IMAGE_NAME):$(TAG) || true

        compose-up:
        \t@docker-compose up -d

        compose-down:
        \t@docker-compose down

        compose-logs:
        \t@docker-compose logs -f

        push:
        \t@docker push $(IMAGE_NAME):$(TAG)
    ''')


def generate_readme(service_name: str, port: int, with_compose: bool) -> str:
    """Generate Docker README."""
    return dedent(f'''\
        # Docker Setup for {service_name}

        Generated by skillpack containerization on {datetime.now().strftime("%Y-%m-%d %H:%M")}

        ## Quick Start

        ### Using Docker directly
        ```bash
        # Build
        make build

        # Run
        make run

        # View logs
        make logs

        # Stop
        make stop
        ```

        ### Using Docker Compose
        ```bash
        # Start all services
        make compose-up

        # View logs
        make compose-logs

        # Stop
        make compose-down
        ```

        ## Endpoints
        - Health: http://localhost:{port}/health
        - API: http://localhost:{port}/

        ## Configuration
        Environment variables can be set in docker-compose.yml or passed via `-e`:
        ```bash
        docker run -e LOG_LEVEL=debug {service_name}
        ```

        ## Production Deployment
        1. Update image tag: `docker build -t {service_name}:v1.0.0 .`
        2. Push to registry: `docker push your-registry/{service_name}:v1.0.0`
        3. Deploy to Kubernetes/ECS/etc.
    ''')
