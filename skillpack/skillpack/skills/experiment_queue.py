"""experiment-queue - Manage experiment queue with checkpointing."""

import argparse
import json
from datetime import datetime
from pathlib import Path
from textwrap import dedent
from typing import Any

import yaml

from skillpack.utils.output import get_output_dir, write_text


def handler(args: argparse.Namespace) -> int:
    """CLI handler for experiment-queue."""
    result = experiment_queue_main(
        queue_name=args.name,
        experiments=None,  # Load from config if provided
        output_dir=args.output_dir,
    )

    if result.get("success"):
        print(f"✅ Generated experiment queue: {result['output_dir']}")
        for f in result.get("files", []):
            print(f"   - {f}")
        return 0
    print(f"❌ Error: {result.get('error')}")
    return 1


def register_parser(subparsers: Any) -> None:
    """Register the experiment-queue subcommand."""
    parser = subparsers.add_parser(
        "experiment-queue",
        help="Manage experiment queue with checkpointing",
    )
    parser.add_argument("--name", required=True, help="Queue name")
    parser.add_argument(
        "--output-dir",
        type=Path,
        default=Path("./out/experiment_queue"),
        help="Output directory",
    )
    parser.set_defaults(handler=handler)


def experiment_queue_main(
    queue_name: str,
    experiments: list[dict] | None = None,
    output_dir: Path | None = None,
) -> dict[str, Any]:
    """Generate experiment queue management code."""
    if output_dir is None:
        output_dir = get_output_dir("experiment_queue")
    else:
        output_dir.mkdir(parents=True, exist_ok=True)

    if experiments is None:
        experiments = generate_sample_experiments()

    try:
        files = []

        # Generate queue manager
        manager = generate_queue_manager(queue_name)
        write_text(content=manager, filename="queue_manager.py", skill_name="experiment_queue", output_dir=output_dir)
        files.append("queue_manager.py")

        # Generate runner script
        runner = generate_runner(queue_name)
        write_text(content=runner, filename="run_queue.py", skill_name="experiment_queue", output_dir=output_dir)
        files.append("run_queue.py")

        # Generate experiment config
        config = generate_experiment_config(queue_name, experiments)
        write_text(content=config, filename="experiments.yaml", skill_name="experiment_queue", output_dir=output_dir)
        files.append("experiments.yaml")

        # Generate checkpoint template
        checkpoint = generate_checkpoint_template(queue_name)
        write_text(content=checkpoint, filename="checkpoint.json", skill_name="experiment_queue", output_dir=output_dir)
        files.append("checkpoint.json")

        return {
            "success": True,
            "output_dir": str(output_dir),
            "files": files,
        }

    except Exception as e:
        return {"success": False, "error": str(e)}


def generate_sample_experiments() -> list[dict]:
    """Generate sample experiment configurations."""
    return [
        {"name": "baseline_rf", "model": "random_forest", "params": {"n_estimators": 100}},
        {"name": "baseline_xgb", "model": "xgboost", "params": {"max_depth": 6}},
        {"name": "tuned_rf", "model": "random_forest", "params": {"n_estimators": 500, "max_depth": 10}},
        {"name": "tuned_xgb", "model": "xgboost", "params": {"max_depth": 8, "learning_rate": 0.1}},
    ]


def generate_queue_manager(name: str) -> str:
    """Generate queue manager class."""
    return dedent(f'''\
        """Experiment queue manager for {name}.

        Generated by skillpack on {datetime.now().strftime("%Y-%m-%d %H:%M")}
        """

        import json
        import logging
        from dataclasses import dataclass, asdict
        from datetime import datetime
        from enum import Enum
        from pathlib import Path
        from typing import Any, Callable

        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger(__name__)


        class ExperimentStatus(Enum):
            PENDING = "pending"
            RUNNING = "running"
            COMPLETED = "completed"
            FAILED = "failed"
            SKIPPED = "skipped"


        @dataclass
        class Experiment:
            name: str
            model: str
            params: dict
            status: ExperimentStatus = ExperimentStatus.PENDING
            started_at: str | None = None
            completed_at: str | None = None
            metrics: dict | None = None
            error: str | None = None


        class ExperimentQueue:
            """Manage a queue of experiments with checkpointing."""
            
            def __init__(self, queue_name: str, checkpoint_path: Path | None = None):
                self.queue_name = queue_name
                self.checkpoint_path = checkpoint_path or Path(f"{{queue_name}}_checkpoint.json")
                self.experiments: list[Experiment] = []
            
            def add_experiment(self, name: str, model: str, params: dict) -> None:
                """Add experiment to queue."""
                exp = Experiment(name=name, model=model, params=params)
                self.experiments.append(exp)
                logger.info(f"Added experiment: {{name}}")
            
            def load_from_config(self, config_path: Path) -> None:
                \"\"\"Load experiments from YAML config.\"\"\"
                import yaml
                
                with open(config_path) as f:
                    config = yaml.safe_load(f)
                
                for exp in config.get("experiments", []):
                    self.add_experiment(
                        name=exp["name"],
                        model=exp["model"],
                        params=exp.get("params", {{}}),
                    )
            
            def save_checkpoint(self) -> None:
                \"\"\"Save current state to checkpoint file.\"\"\"
                state = {{
                    "queue_name": self.queue_name,
                    "updated_at": datetime.now().isoformat(),
                    "experiments": [
                        {{
                            "name": e.name,
                            "model": e.model,
                            "params": e.params,
                            "status": e.status.value,
                            "started_at": e.started_at,
                            "completed_at": e.completed_at,
                            "metrics": e.metrics,
                            "error": e.error,
                        }}
                        for e in self.experiments
                    ],
                }}
                
                with open(self.checkpoint_path, "w") as f:
                    json.dump(state, f, indent=2)
                
                logger.info(f"Checkpoint saved: {{self.checkpoint_path}}")
            
            def load_checkpoint(self) -> bool:
                \"\"\"Load state from checkpoint file.\"\"\"
                if not self.checkpoint_path.exists():
                    return False
                
                with open(self.checkpoint_path) as f:
                    state = json.load(f)
                
                self.experiments = []
                for e in state.get("experiments", []):
                    exp = Experiment(
                        name=e["name"],
                        model=e["model"],
                        params=e["params"],
                        status=ExperimentStatus(e["status"]),
                        started_at=e.get("started_at"),
                        completed_at=e.get("completed_at"),
                        metrics=e.get("metrics"),
                        error=e.get("error"),
                    )
                    self.experiments.append(exp)
                
                logger.info(f"Loaded {{len(self.experiments)}} experiments from checkpoint")
                return True
            
            def get_pending(self) -> list[Experiment]:
                \"\"\"Get pending experiments.\"\"\"
                return [e for e in self.experiments if e.status == ExperimentStatus.PENDING]
            
            def get_summary(self) -> dict:
                \"\"\"Get queue summary.\"\"\"
                return {{
                    "total": len(self.experiments),
                    "pending": len([e for e in self.experiments if e.status == ExperimentStatus.PENDING]),
                    "running": len([e for e in self.experiments if e.status == ExperimentStatus.RUNNING]),
                    "completed": len([e for e in self.experiments if e.status == ExperimentStatus.COMPLETED]),
                    "failed": len([e for e in self.experiments if e.status == ExperimentStatus.FAILED]),
                }}
            
            def run_experiment(
                self,
                experiment: Experiment,
                train_fn: Callable[[str, dict], dict],
            ) -> None:
                \"\"\"Run a single experiment.\"\"\"
                experiment.status = ExperimentStatus.RUNNING
                experiment.started_at = datetime.now().isoformat()
                self.save_checkpoint()
                
                try:
                    logger.info(f"Running: {{experiment.name}}")
                    metrics = train_fn(experiment.model, experiment.params)
                    
                    experiment.status = ExperimentStatus.COMPLETED
                    experiment.completed_at = datetime.now().isoformat()
                    experiment.metrics = metrics
                    logger.info(f"Completed: {{experiment.name}}")
                    
                except Exception as e:
                    experiment.status = ExperimentStatus.FAILED
                    experiment.completed_at = datetime.now().isoformat()
                    experiment.error = str(e)
                    logger.error(f"Failed: {{experiment.name}} - {{e}}")
                
                self.save_checkpoint()
            
            def run_all(self, train_fn: Callable[[str, dict], dict]) -> None:
                \"\"\"Run all pending experiments.\"\"\"
                pending = self.get_pending()
                logger.info(f"Running {{len(pending)}} experiments...")
                
                for exp in pending:
                    self.run_experiment(exp, train_fn)
                
                summary = self.get_summary()
                logger.info(f"Queue complete: {{summary}}")
    ''')


def generate_runner(name: str) -> str:
    """Generate runner script."""
    return dedent(f'''\
        #!/usr/bin/env python3
        """Run experiment queue for {name}.

        Generated by skillpack on {datetime.now().strftime("%Y-%m-%d %H:%M")}
        """

        import argparse
        from pathlib import Path

        from queue_manager import ExperimentQueue


        def train_model(model_type: str, params: dict) -> dict:
            \"\"\"Train a model and return metrics.
            
            TODO: Implement your actual training logic here.
            \"\"\"
            print(f"Training {{model_type}} with params: {{params}}")
            
            # Placeholder - replace with actual training
            import time
            import random
            
            time.sleep(1)  # Simulate training
            
            return {{
                "accuracy": random.uniform(0.8, 0.95),
                "f1": random.uniform(0.75, 0.92),
            }}


        def main():
            parser = argparse.ArgumentParser()
            parser.add_argument("--config", type=Path, default=Path("experiments.yaml"))
            parser.add_argument("--resume", action="store_true", help="Resume from checkpoint")
            parser.add_argument("--status", action="store_true", help="Show queue status")
            args = parser.parse_args()
            
            queue = ExperimentQueue("{name}")
            
            # Load from checkpoint or config
            if args.resume and queue.load_checkpoint():
                print("Resuming from checkpoint...")
            else:
                queue.load_from_config(args.config)
            
            if args.status:
                print(queue.get_summary())
                return
            
            # Run experiments
            queue.run_all(train_model)
            
            # Print final summary
            print("\\n=== Final Summary ===")
            print(queue.get_summary())


        if __name__ == "__main__":
            main()
    ''')


def generate_experiment_config(name: str, experiments: list[dict]) -> str:
    """Generate experiment configuration YAML."""
    return yaml.dump({
        "queue_name": name,
        "experiments": experiments,
    }, default_flow_style=False)


def generate_checkpoint_template(name: str) -> str:
    """Generate checkpoint JSON template."""
    return json.dumps({
        "queue_name": name,
        "updated_at": datetime.now().isoformat(),
        "experiments": [],
    }, indent=2)
